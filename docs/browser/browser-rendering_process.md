---
title: 渲染过程
order: 2
group:
  title: browser
  order: 1
---

1.  ##### 浏览器查找域名对应的 IP 地址

    > ###### 查找顺序（假定查找返回的结果是 null|undefined，便于理解）
    >
    > 浏览器缓存 ?? 系统缓存 ?? 路由器缓存 ?? 本地 DNS 服务器缓存 ?? 本地 DNS 服务器查询 ?? 根域名服务器 && 顶级域名服务器 && 权威域名服务器

    > ###### 详细查找过程
    >
    > 1. 浏览器搜索自己的 DNS 缓存
    > 2. 搜索操作系统中的 DNS 缓存
    > 3. 搜索路由器中的 DNS 缓存
    > 4. LDNS（本地域名服务器）查询缓存
    > 5. LDNS 向 Root Name Server（根域名服务器）发起请求，返回顶级域名服务器的地址(com 域等)
    > 6. LDNS 向顶级域名服务器发起请求，返回域名服务器地址
    > 7. LDNS 向域名发起请求，返回域名的 ip 地址
    > 8. ip 返回给操作系统缓存 => 操作系统发送给浏览器缓存

2.  ##### 浏览器根据 IP 地址与服务器建立 socket 连接

    > ###### TCP🤝 过程
    >
    > 1. 第一次 🤝：建立连接。客户端发送连接请求报文段，将 SYN 位置为 1，Sequence Number 为 x；然后，客户端进入 SYN_SEND 状态，等待服务器的确认；
    > 2. 第二次 🤝：服务器收到 SYN 报文段。服务器收到客户端的 SYN 报文段，需要对这个 SYN 报文段进行确认，设置 Acknowledgment Number 为 x+1(Sequence Number+1)；同时，自己还要发送 SYN 请求信息，将 SYN 位置为 1，Sequence Number 为 y；服务器端将上述所有信息放到一个报文段（即 SYN+ACK 报文段）中，一并发送给客户端，此时服务器进入 SYN_RECV 状态；
    > 3. 第三次 🤝：客户端收到服务器的 SYN+ACK 报文段。然后将 Acknowledgment Number 设置为 y+1，向服务器发送 ACK 报文段，这个报文段发送完毕以后，客户端和服务器端都进入 ESTABLISHED 状态，完成 TCP 三次握手。

    > ###### SSL 握手过程
    >
    > 1. 第一阶段：建立安全能力，包括协议版本、会话 id、密码构件、压缩方法和初始随机数
    > 2. 第二阶段：服务器发送证书，密钥交换数据和证书请求
    > 3. 第三阶段：如果有证书请求，客户端发送此证书，之后客户端发送密钥交换数据，也可以发送证书验证消息
    > 4. 第四阶段：变更密码构件和结束握手协议

    > ###### ACK & SYN & FIN
    >
    > ACK：此标志表示应答域有效，就是说前面所说的 TCP 应答号将会包含在 TCP 数据包中；有两个取值：0 和 1，为 1 的时候表示应答域有效，反之为 0。TCP 协议规定，只有 ACK=1 时有效，也规定连接建立后所有发送的报文的 ACK 必须为 1。
    > SYN(SYNchronization)：在连接建立时用来同步序号。当 SYN=1 而 ACK=0 时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使 SYN=1 和 ACK=1. 因此, SYN 置 1 就表示这是一个连接请求或连接接受报文。
    > FIN(finis）：即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。

3.  ##### 浏览器与服务器通信： 浏览器请求，服务器处理请求
    [协商缓存](/browser/caching_strategy#协商缓存)

    <!-- > 如果头部携带 If-None-Match / If-Modified-Since，则验证缓存是否有效 -->

4.  ##### 浏览器与服务器断开连接

    > ###### TCP👋🏻 过程
    >
    > 1. 第一次 👋🏻： 主机 1（可以是客户端，也可以是服务器端），设置 Sequence Number 和 Acknowledgment Number，向主机 2 发送一个 FIN 报文段；此时，主机 1 进入 FIN_WAIT_1 状态；这表示主机 1 没有数据要发送给主机 2 了；
    > 2. 第二次 👋🏻： 主机 2 收到了主机 1 发送的 FIN 报文段，向主机 1 回一个 ACK 报文段，Acknowledgment Number 为 Sequence Number 加 1；主机 1 进入 FIN_WAIT_2 状态；主机 2 告诉主机 1，我"同意"你的关闭请求；
    > 3. 第三次 👋🏻：主机 2 向主机 1 发送 FIN 报文段，请求关闭连接，同时主机 2 进入 LAST_ACK 状态；
    > 4. 第四次 👋🏻：主机 1 收到主机 2 发送的 FIN 报文段，向主机 2 发送 ACK 报文段，然后主机 1 进入 TIME_WAIT 状态；主机 2 收到主机 1 的 ACK 报文段以后，就关闭连接；此时，主机 1 等待 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，主机 1 也可以关闭连接了。

5.  ##### 浏览器渲染

    > ###### 构建 DOM 树
    >
    > html 内容 => DOM 树
    >
    > ###### 样式计算
    >
    > css 样式转化为浏览器可以理解的 styleSheets，计算 ODM 节点的样式
    >
    > ###### 页面布局
    >
    > 排除 script、meta、display: none 等节点，计算元素的位置信息，构建一颗只包含可见元素的布局树
    >
    > ###### 生成分层树
    >
    > 3d 变换、z-index 做 z 轴排序等，渲染引擎为特定的节点（z-index 不为 auto 的绝对/相对定位元素、opacity<1、position:fixed/sticky 等）生成专用的图层，并生成一棵对应的图层树（LayerTree）
    >
    > ###### 计算当前位置
    >
    > 渲染时只会渲染可视区域部分，对需要渲染的图层分块，之后开始光栅化绘制，浏览器通过显卡把需要现实的内容发送给显示器，显示器读取缓冲区的内容，根据逐行扫描的方式进行渲染
    >
    > ###### 渲染完成
    >
    > ###### 其他问题
    >
    > 渲染过程中，css、js 是否会阻塞渲染？
    >
    > 1. CSS 不会阻塞 DOM 的解析，但会阻塞 DOM 渲染
    > 2. 无async/defer的JS 阻塞 DOM 解析渲染，但浏览器会"偷看"DOM，预先下载相关资源
    >  - async，异步请求脚本资源，如果脚本请求成功时DOM依旧没有解析完成，则暂停待脚本执行完成之后继续解析DOM
    >  - defer，异步请求脚本资源，等DOM解析完成之后再执行脚本
    > 3. 浏览器遇到 <script>且没有 defer 或 async 属性的 标签时，会触发页面渲染，因而如果前面 CSS 资源尚未加载完毕时，浏览器会等待它加载完毕在执行脚本
